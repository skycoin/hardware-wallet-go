// Code generated by mockery v1.0.0. DO NOT EDIT.

package skywallet

import (
	messages "github.com/skycoin/hardware-wallet-protob/go"
	mock "github.com/stretchr/testify/mock"

	wire "github.com/skycoin/hardware-wallet-go/src/skywallet/wire"
)

// MockDevicer is an autogenerated mock type for the Devicer type
type MockDevicer struct {
	mock.Mock
}

// AddressGen provides a mock function with given fields: addressN, startIndex, confirmAddress, coinType
func (_m *MockDevicer) AddressGen(addressN uint32, startIndex uint32, confirmAddress bool, coinType CoinType) (wire.Message, error) {
	ret := _m.Called(addressN, startIndex, confirmAddress, coinType)

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func(uint32, uint32, bool, CoinType) wire.Message); ok {
		r0 = rf(addressN, startIndex, confirmAddress, coinType)
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint32, uint32, bool, CoinType) error); ok {
		r1 = rf(addressN, startIndex, confirmAddress, coinType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ApplySettings provides a mock function with given fields: usePassphrase, label, language
func (_m *MockDevicer) ApplySettings(usePassphrase *bool, label string, language string) (wire.Message, error) {
	ret := _m.Called(usePassphrase, label, language)

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func(*bool, string, string) wire.Message); ok {
		r0 = rf(usePassphrase, label, language)
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bool, string, string) error); ok {
		r1 = rf(usePassphrase, label, language)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Available provides a mock function with given fields:
func (_m *MockDevicer) Available() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Backup provides a mock function with given fields:
func (_m *MockDevicer) Backup() (wire.Message, error) {
	ret := _m.Called()

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func() wire.Message); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ButtonAck provides a mock function with given fields:
func (_m *MockDevicer) ButtonAck() (wire.Message, error) {
	ret := _m.Called()

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func() wire.Message); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cancel provides a mock function with given fields:
func (_m *MockDevicer) Cancel() (wire.Message, error) {
	ret := _m.Called()

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func() wire.Message); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChangePin provides a mock function with given fields: removePin
func (_m *MockDevicer) ChangePin(removePin *bool) (wire.Message, error) {
	ret := _m.Called(removePin)

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func(*bool) wire.Message); ok {
		r0 = rf(removePin)
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bool) error); ok {
		r1 = rf(removePin)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckMessageSignature provides a mock function with given fields: message, signature, address
func (_m *MockDevicer) CheckMessageSignature(message string, signature string, address string) (wire.Message, error) {
	ret := _m.Called(message, signature, address)

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func(string, string, string) wire.Message); ok {
		r0 = rf(message, signature, address)
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(message, signature, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Close provides a mock function with given fields:
func (_m *MockDevicer) Close() {
	_m.Called()
}

// Connect provides a mock function with given fields:
func (_m *MockDevicer) Connect() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Connected provides a mock function with given fields:
func (_m *MockDevicer) Connected() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Disconnect provides a mock function with given fields:
func (_m *MockDevicer) Disconnect() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FirmwareUpload provides a mock function with given fields: payload, hash
func (_m *MockDevicer) FirmwareUpload(payload []byte, hash [32]byte) error {
	ret := _m.Called(payload, hash)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, [32]byte) error); ok {
		r0 = rf(payload, hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GenerateMnemonic provides a mock function with given fields: wordCount, usePassphrase
func (_m *MockDevicer) GenerateMnemonic(wordCount uint32, usePassphrase bool) (wire.Message, error) {
	ret := _m.Called(wordCount, usePassphrase)

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func(uint32, bool) wire.Message); ok {
		r0 = rf(wordCount, usePassphrase)
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint32, bool) error); ok {
		r1 = rf(wordCount, usePassphrase)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFeatures provides a mock function with given fields:
func (_m *MockDevicer) GetFeatures() (wire.Message, error) {
	ret := _m.Called()

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func() wire.Message); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PassphraseAck provides a mock function with given fields: passphrase
func (_m *MockDevicer) PassphraseAck(passphrase string) (wire.Message, error) {
	ret := _m.Called(passphrase)

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func(string) wire.Message); ok {
		r0 = rf(passphrase)
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(passphrase)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PinMatrixAck provides a mock function with given fields: p
func (_m *MockDevicer) PinMatrixAck(p string) (wire.Message, error) {
	ret := _m.Called(p)

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func(string) wire.Message); ok {
		r0 = rf(p)
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Recovery provides a mock function with given fields: wordCount, usePassphrase, dryRun
func (_m *MockDevicer) Recovery(wordCount uint32, usePassphrase *bool, dryRun bool) (wire.Message, error) {
	ret := _m.Called(wordCount, usePassphrase, dryRun)

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func(uint32, *bool, bool) wire.Message); ok {
		r0 = rf(wordCount, usePassphrase, dryRun)
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(uint32, *bool, bool) error); ok {
		r1 = rf(wordCount, usePassphrase, dryRun)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetAutoPressButton provides a mock function with given fields: simulateButtonPress, simulateButtonType
func (_m *MockDevicer) SetAutoPressButton(simulateButtonPress bool, simulateButtonType ButtonType) error {
	ret := _m.Called(simulateButtonPress, simulateButtonType)

	var r0 error
	if rf, ok := ret.Get(0).(func(bool, ButtonType) error); ok {
		r0 = rf(simulateButtonPress, simulateButtonType)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetMnemonic provides a mock function with given fields: mnemonic
func (_m *MockDevicer) SetMnemonic(mnemonic string) (wire.Message, error) {
	ret := _m.Called(mnemonic)

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func(string) wire.Message); ok {
		r0 = rf(mnemonic)
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(mnemonic)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SignMessage provides a mock function with given fields: addressIndex, message
func (_m *MockDevicer) SignMessage(addressIndex int, message string) (wire.Message, error) {
	ret := _m.Called(addressIndex, message)

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func(int, string) wire.Message); ok {
		r0 = rf(addressIndex, message)
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int, string) error); ok {
		r1 = rf(addressIndex, message)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransactionSign provides a mock function with given fields: inputs, outputs
func (_m *MockDevicer) TransactionSign(inputs []*messages.SkycoinTransactionInput, outputs []*messages.SkycoinTransactionOutput) (wire.Message, error) {
	ret := _m.Called(inputs, outputs)

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func([]*messages.SkycoinTransactionInput, []*messages.SkycoinTransactionOutput) wire.Message); ok {
		r0 = rf(inputs, outputs)
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]*messages.SkycoinTransactionInput, []*messages.SkycoinTransactionOutput) error); ok {
		r1 = rf(inputs, outputs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Wipe provides a mock function with given fields:
func (_m *MockDevicer) Wipe() (wire.Message, error) {
	ret := _m.Called()

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func() wire.Message); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WordAck provides a mock function with given fields: word
func (_m *MockDevicer) WordAck(word string) (wire.Message, error) {
	ret := _m.Called(word)

	var r0 wire.Message
	if rf, ok := ret.Get(0).(func(string) wire.Message); ok {
		r0 = rf(word)
	} else {
		r0 = ret.Get(0).(wire.Message)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(word)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
